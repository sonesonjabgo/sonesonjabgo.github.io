{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/React","result":{"pageContext":{"currentCategory":"React","categories":["All","React","javascript","TypeScript","Next","Angular","test"],"edges":[{"node":{"id":"d49d018a-a8fb-54d2-9b01-e4964a38d709","excerpt":"리액트 프로젝트에서 파일을 업로드하고 관리하는 방법 리액트 프로젝트에서 파일을 업로드하고 관리하는 방법을 정리해봤다. 기본 파일 업로드부터 드래그 앤 드롭 기능까지 구현하는 방법을 살펴보겠다. 기본 파일 업로드 구현\r\n파일 업로드의 기본 방법은 input 태그를 사용하는 것이었다. 아래 코드는 사용자가 파일을 선택하고 미리보기를 제공하는 예시이다: 이 코드에서 FileReader는 파일을 읽고 data URL로 변환하여 이미지 미리보기를 제공하는 역할을 한다. reader.onload는 파일 읽기가 완료된 후 실행되며, 결과를 setPreview를 통해 상태로 저장한다. 드래그 앤 드롭 기능 추가 기존의 파일 업로드 코드에 드래그 앤 드롭 기능을 추가할 때, 파일을 드래그하거나 드롭할 수 있는 영역을 정의해야 했다. 이때 사용한 코드는 다음과 같다: 드래그 앤 드롭 기능을 구현할 때, handleDragOver는 파일이 드래그되었을 때 호출되어 드래그 상태를 유지하도록 한다. ha…","fields":{"slug":"/react-upload/"},"frontmatter":{"categories":"React","title":"리액트에서 이미지 업로드","date":"August 22, 2024"}},"next":{"fields":{"slug":"/react-deatwitharray/"}},"previous":null},{"node":{"id":"428518c7-e3eb-5fae-a6c3-f4921ef10d77","excerpt":"React에서 중복되지 않는 선택된 클래스 배열 만들기 기존 코드의 문제점 최근 프로젝트에서  배열에 사용자 선택 클래스를 추가하면서 중복된  값을 가진 객체가 여러 개 들어가는 문제가 발생했다. 원래 코드는 단순히 클래스를 추가하고 중복을 제거하는 방식이었는데, 이 방식은 시간 복잡도가 높아 비효율적이었다. 배열을 순회하면서 중복을 확인하는 데 O(n * m) 시간이 소요됐고, 데이터가 많아질수록 성능에 영향을 미쳤다. 그래서 성능을 개선하고자 시간을 단축할 수 있는 방법을 고민해봤다. 해시맵을 활용한 개선 해시맵을 사용하여 에 대한 빠른 검색을 구현하고, 중복을 효율적으로 제거하는 방법을 적용해봤다. 이 방법을 사용하면 시간 복잡도를 줄이고, 애플리케이션의 성능을 크게 향상시킬 수 있다. 이제 이 방법을 어떻게 적용했는지 설명하겠다. 데이터 형식 처음에는 와  데이터 형식을 사용하고 있었음. 데이터는 다음과 같다: 해시맵으로 변환 먼저, Cls 객체를 해시맵으로 변환했다. 이렇…","fields":{"slug":"/react-deatwitharray/"},"frontmatter":{"categories":"React javascript","title":"중복되지 않는 선택된 클래스 배열 만들기","date":"August 20, 2024"}},"next":{"fields":{"slug":"/react-dropdown/"}},"previous":{"fields":{"slug":"/react-upload/"}}},{"node":{"id":"1dc837ea-0717-5fa6-9f21-c5b21490f055","excerpt":"리액트 프로젝트에서 드롭다운 메뉴를 만들어야 했다.  위 사진과 같고 각각의 메뉴는 독립적으로 열리고 닫히기가 가능해야 한다. groups는 전체 그룹들을 담고있는 배열이고 groups와 길이가 같은 false로만 채운 배열을 기본값으로 설정 토글 함수로 해당하는 인덱스 번호의 상태를 변화시킴 div를 눌렀을 때 openMenus[index]의 상태를 변경시키고 그 상태에 따라 하위 메뉴를 보여준다.\r\n(classes는 하위 메뉴를 전부 담고있는 배열) 이렇게 하여 드롭다운 메뉴를 독립적으로 열리고 닫히도록 한 번에 관리할 수 있게 만들었다.","fields":{"slug":"/react-dropdown/"},"frontmatter":{"categories":"React javascript","title":"드롭다운 메뉴","date":"August 12, 2024"}},"next":{"fields":{"slug":"/react-mockData/"}},"previous":{"fields":{"slug":"/react-deatwitharray/"}}},{"node":{"id":"c8931809-dc8f-5bab-bbca-bc209886e300","excerpt":"회사에서 동기와 작업 중 인데 (나 프론트 동기 백엔드)\r\n동기가 이슈로 인해 작업 진도가 좀 차질이 생겼다. 언제까지 api를 기다릴 수 없기 때문에 임시 데이터를 만들어서 작업하자고 생각했다. Faker.js vs Mock data 전에 Faker.js 를 사용했었는데 임시 값 들이 임시라고 해도 너무 안맞는 것 같았다. ui를 그려낼 수는 있지만 오히려 헷갈렸다. 그래서 mock data를 만들어서 사용하기로 생각했다. 적용 \r\n위 사진과 같이 public - data 폴더 안에 json 파일을 만들어주면 된다. \r\n그리고 위와 같이 경로에다가 요청을 하면 된다. 주의할 점 GET 만 가능하다. 당연한거긴 하다.. (next 쓰고 싶다..)","fields":{"slug":"/react-mockData/"},"frontmatter":{"categories":"React","title":"리액트 임시 데이터","date":"August 09, 2024"}},"next":{"fields":{"slug":"/react-arraySort/"}},"previous":{"fields":{"slug":"/react-dropdown/"}}},{"node":{"id":"75402d32-25c0-57f6-9ace-23935f1790ec","excerpt":"위와 같은 셀렉트 태그가 있다.\r\n선택된 옵션에 따라 projectList가 정렬되어야 한다. 우선 셀렉트 태그에 value와 값 변경 시 실행할 함수를 줬다. 그런 다음 handleChange를 정의했다.\r\n해당 함수는 선택한 옵션에 따라 다른 함수를 실행하게 하여 원하는 값을 기준으로 정렬하게 했다 (sort((a,b)=>{})) 사용 그런 다음 sortOptions라는 객체에 셀렉트 태그의 value를 key 값으로 실행되어야 할 함수를 묶어서 만들었다. 이렇게 되면 셀렉트 태그를 통해 골라진 값이 event.target.value가 되어 sortOptions의 key로 넘어가게 된 뒤 그에 맞는 함수가 실행되어 filterList가 sort된다.","fields":{"slug":"/react-arraySort/"},"frontmatter":{"categories":"React javascript","title":"셀렉트 태그 이벤트를 통한 정렬","date":"August 08, 2024"}},"next":{"fields":{"slug":"/typeScript-generics/"}},"previous":{"fields":{"slug":"/react-mockData/"}}},{"node":{"id":"418674e7-63d9-534f-a7af-6d141fbfb241","excerpt":"useEffect useEffect ( func, deps ) func는 콜백 함수, deps는 배열인데 배열 안의 값이 변하면 useEffect가 실행되도록 설정함 deps에 아무런 값을 주지 않는다면, 모든 변화를 감지함 빈 배열을 주면 mount에만 실행됨 componentDidMount(), componentDidUpdate(), componentWillUnmount() 역할을 함 componentWillUnmount시에 필요한 역할은 func의 return으로 함수를 넣으면 같은 기능을 한다. (클린업 함수) 위 코드에서 처음 로그 실행은 1 > 2 > mount 순으로 진행됨 useEffect는 랜더링 후 시점에 실행됨 input에 값이 입력 됐을 때 input의 value가 변하면서 input이 리랜더링 됨. useEffect의 두 번째 인자 deps안의 input 값이 변경돼서 이 경우 클린업 함수가 실행되어 1 > 2 > mount > 1 > 2 > unmount …","fields":{"slug":"/react-hooks/"},"frontmatter":{"categories":"React","title":"리액트 hooks","date":"July 24, 2024"}},"next":{"fields":{"slug":"/javascript-searchBar/"}},"previous":{"fields":{"slug":"/typeScript-generics/"}}},{"node":{"id":"b2b65055-ed5a-5416-97c4-b56f13483151","excerpt":"await를 해야하는 부분을 명시적으로 나타내는 것 이것이 의미하는 것 React 18에 추가됨 SPA의 단점인 초기 랜더링에 시간이 오래걸리는 문제를 해결 할 수 있음.  Comments에서 fetch 같은 비동기 작업 때문에 랜더링 되는데 시간이 걸림 Suspense는 Comments가 await 해야함을 알리고 다른 컴포넌트들을 먼저 랜더링함. next에서 활용 Movie Detail 페이지가 랜더링되면 movie와 videos는 동기적으로 실행된다\r\n 두 함수가 실행된 시간이 다르다는 것을 알 수 있음 위 함수들은 동기적으로 실행될 필요가 없다. 비동기적으로 실행하려면 어떻게 할까? Promise.all() 위와 같이 코드를 변경하면 되는데 배열 안에 있는 함수들을 비동기적으로 실행시키고 그 결과값을 배열로 전해준다. 여기에 문제가 있는데 위 코드는 배열 안 함수가 모두 종료되어야 결과값이 나온다. 동시에 시작 > 모든 함수 종료될 때 까지 기다림 Suspense Suspe…","fields":{"slug":"/react-suspense/"},"frontmatter":{"categories":"React Next","title":"Suspense","date":"July 16, 2024"}},"next":{"fields":{"slug":"/next-DataFetching/"}},"previous":{"fields":{"slug":"/next-darkmode/"}}},{"node":{"id":"6e1a42db-4341-53d3-84fe-e3f3e2f836b2","excerpt":"Rules of Hooks React Hook을 사용할 때 따라야 할 몇 가지 중요한 규칙 이 규칙들은 Hook이 일관되게 동작하도록 하기 위함이다. 최상위에서만 Hook 호출하기 Hook은 함수 컴포넌트의 최상위 수준에서만 호출해야 한다. 조건문, 반복문, 중첩된 함수 내에서 Hook 호출해서는 안됨. 이렇게 해야 동일한 순서로 호출되는 것을 보장 할 수 있다. React 함수 컴포넌트 또는 커스텀 Hook 안에서만 Hook 호출하기 일반 자바스크립트 함수나 클래스 컴포넌트에서 Hook을 호출하면 안됨.","fields":{"slug":"/react-rulesOfHooks/"},"frontmatter":{"categories":"React","title":"리액트 Rules of Hooks","date":"July 12, 2024"}},"next":{"fields":{"slug":"/next-env/"}},"previous":{"fields":{"slug":"/next-hydration/"}}},{"node":{"id":"895d88b0-7e6a-546a-96c8-42950a022f43","excerpt":"Prop drilling vs Context API, How the data is passed Props Drilling props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정 여러 컴포넌트를 거쳐 prop 된다면 데이터 추적이 어려워 유지보수가 어려워지게 된다. context를 이용하면 단계마다 일일이 props를 넘겨주지 않고도 컴포넌트 트리 전체에 데이터를 제공할 수 있음 언제 context를 써야 할까 context는 트리 안에서 전역적이라고 볼 수 있는 데이터를 공유하도록 고안된 방법 ex : 현재 로그인한 유저 정보, 테마, 선호 언어 등 API React.createContext context 객체를 만듦 context 객체를 구독하고 있는 컴포넌트를 랜더링할 때 React는 트리 상위에서 가장 가까이 있는 짝이 맞는 Provider로부터 현재값을 읽음 Co…","fields":{"slug":"/react-contextApi/"},"frontmatter":{"categories":"React","title":"리액트 Context API","date":"July 10, 2024"}},"next":{"fields":{"slug":"/next-appRouter/"}},"previous":{"fields":{"slug":"/next-env/"}}},{"node":{"id":"138616d6-d8e0-5ce6-bf04-410a2b0d69b2","excerpt":"리액트는 key가 동일 할 경우, 동일한 DOM Element를 보여줌 때문에 key를 index로 뒀을 때 문제가 생길 수 있다. 예시 line 22, 23: 추가, 삭제 버튼. 추가 버튼을 누르면 정국 데이터를 list 앞에 추가하고 삭제를 누르면 철수를 삭제한다. line 28: component가 관리하는 list 데이터를 map으로 loop 돌며 div 태그의 key를 index로 지정한다. 추가할 때 \r\n철수 input에 데이터를 입력 \r\n추가 버튼을 눌렀을 때 \r\n이러한 결과를 예상했지만 \r\n이러한 결과가 나온다. list 값이 변경되면서 index를 다시 mapping함 맨 앞에 추가된 정국은 key = 0 key가 동일 할 경우, 동일한 DOM Element 보여줌 삭제할 때 \r\n위 상황에서 삭제를 눌렀을 때 \r\n이러한 결과를 예상하지만 \r\n이러한 결과가 나온다. 삭제가 되면서 다시 mapping 영희가 철수의 index였던 0이 됨 철수 데이터가 영희에게 mapp…","fields":{"slug":"/react-mapKeyIndex/"},"frontmatter":{"categories":"React","title":"리액트 배열의 index로 key를 쓰면 안되는 이유","date":"July 03, 2024"}},"next":{"fields":{"slug":"/angular-form/"}},"previous":{"fields":{"slug":"/next-folder-tips/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}