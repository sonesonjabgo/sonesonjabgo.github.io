{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"1d3c2f29-9fbc-5b62-9e1c-5661d367bab2","excerpt":"await를 해야하는 부분을 명시적으로 나타내는 것 이것이 의미하는 것 React 18에 추가됨 SPA의 단점인 초기 랜더링에 시간이 오래걸리는 문제를 해결 할 수 있음.  Comments에서 fetch 같은 비동기 작업 때문에 랜더링 되는데 시간이 걸림 Suspense는 Comments가 await 해야함을 알리고 다른 컴포넌트들을 먼저 랜더링함. next에서 활용 Movie Detail 페이지가 랜더링되면 movie와 videos는 동기적으로 실행된다\r\n 두 함수가 실행된 시간이 다르다는 것을 알 수 있음 위 함수들은 동기적으로 실행될 필요가 없다. 비동기적으로 실행하려면 어떻게 할까? Promise.all() 위와 같이 코드를 변경하면 되는데 배열 안에 있는 함수들을 비동기적으로 실행시키고 그 결과값을 배열로 전해준다. 여기에 문제가 있는데 위 코드는 배열 안 함수가 모두 종료되어야 결과값이 나온다. 동시에 시작 > 모든 함수 종료될 때 까지 기다림 Suspense Suspe…","frontmatter":{"categories":"React, Next","title":"Suspense,","date":"July 16, 2024"},"fields":{"slug":"/react-suspense/"}}},{"node":{"id":"df71dc4b-c17b-5d0e-b593-7fa26d07be95","excerpt":"기존의 방법 (리액트) next js에서의 방식 바뀐 방식은 리액트 훅을 사용하지 않아도 됨 next js는 프레임워크로써 fetch한 데이터를 프레임워크에서 저장한 후 클라이언트에 캐싱하는 방식을 사용한다. 때문에 위의 코드는 서버에서 실행되어 클라이언트에 보여지는 것 next js 프레임워크가 한 번 실행된 fetch는 메모리에 캐싱해둠 때문에 같은 페이지를 다시 접속할 때 불필요한 fetch를 줄이고 페이지를 빠르게 보여주게 한다.","frontmatter":{"categories":"Next","title":"next.js 데이터 페칭","date":"July 16, 2024"},"fields":{"slug":"/next-DataFetching/"}}},{"node":{"id":"a718f923-367f-5047-abdf-4ca8289ee373","excerpt":"meta data 메타데이터를 사용하여 head에 표시될 정보를 간편하게 바꿀 수 있다. next js는 메타데이터의 타입도 제공함 규칙에 맞춰 넣으면 된다 메타데이터는 layout.tsx와 page.tsx에만 작성 가능하다. client component에서는 메타데이터 export 불가능하다. 공식 문서 : https://nextjs.org/docs/app/building-your-application/optimizing/metadata","frontmatter":{"categories":"Next","title":"next.js 메타 데이터","date":"July 15, 2024"},"fields":{"slug":"/next-metaData/"}}},{"node":{"id":"ee4a0e5c-b397-577c-b42e-0e76be9023df","excerpt":"하이드레이션(Hydration)이란? 서버사이드 렌더링(SSR)을 통해 만들어 진 인터랙티브 하지 않는 HTML을 클라이언트 측 자바스크립트를 사용하여 인터랙티브한 리액트 컴포넌트로 변환하는 과정을 말한다.\r\n(서버 환경에서 이미 렌더링된 HTML에 React를 붙이는 것) in Next.JS next js는 기본적으로 SSR 방식으로 랜더링 한다. 여기서 hydration이 적용이 되는데 초기 Html 파일을 먼저 전달하고 이후 HTML 요소들을 React 컴포넌트로 변환 및 이벤트리스너를 부착하여 React DOM에서 관리하게 한다. 이 과정을 Hydration(수분 보충)이라고 한다. 정리 next js가 정적인 html을 먼저 띄우고 그 뒤에 hydration이 이루어짐 이 과정 덕에 SPA의 단점인 초기 랜더링 시 오래 걸리는 문제를 해결함 자바스크립트가 랜더링 하는 것을 기다리지 않기 때문 hydration은 단순 HTML을 React application으로 초기화 하…","frontmatter":{"categories":"Next","title":"next.js hydration","date":"July 15, 2024"},"fields":{"slug":"/next-hydration/"}}},{"node":{"id":"830c947e-a289-5690-a98a-cb96e720d72c","excerpt":"Rules of Hooks React Hook을 사용할 때 따라야 할 몇 가지 중요한 규칙 이 규칙들은 Hook이 일관되게 동작하도록 하기 위함이다. 최상위에서만 Hook 호출하기 Hook은 함수 컴포넌트의 최상위 수준에서만 호출해야 한다. 조건문, 반복문, 중첩된 함수 내에서 Hook 호출해서는 안됨. 이렇게 해야 동일한 순서로 호출되는 것을 보장 할 수 있다. React 함수 컴포넌트 또는 커스텀 Hook 안에서만 Hook 호출하기 일반 자바스크립트 함수나 클래스 컴포넌트에서 Hook을 호출하면 안됨.","frontmatter":{"categories":"React","title":"리액트 Rules of Hooks","date":"July 12, 2024"},"fields":{"slug":"/react-rulesOfHooks/"}}},{"node":{"id":"e1b6bd47-2190-53be-9324-94fbec4a31c1","excerpt":"env 파일 요청 보낼 주소나 api key 같은 드러나지 않았으면 하는 값들을 env 파일에 넣어서 관리한다 글을 쓰게 된 이유 api key를 env 파일에 넣어서 쓰고 있었는데 불러보니 undefined였다. 어이가 없는 건 이 문제를 발견하게 되기 전 까지 다른 곳에서 잘 불러서 쓰고 있었다. 찾아낸 사실 next env 파일에 변수 이름 앞에 NEXTPUBLIC를 붙여줘야 인식한다. 나는 ssr에서 불러서 쓸 때는 문제가 없었지만 csr에서 부르니 안됐다. 아마 인식 문제는 csr에서만 적용되는 듯 하다.","frontmatter":{"categories":"Next","title":"next.js env","date":"July 12, 2024"},"fields":{"slug":"/next-env/"}}},{"node":{"id":"0cf87a6d-7252-52df-8f36-dec1ac59f42e","excerpt":"Prop drilling vs Context API, How the data is passed Props Drilling props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정 여러 컴포넌트를 거쳐 prop 된다면 데이터 추적이 어려워 유지보수가 어려워지게 된다. context를 이용하면 단계마다 일일이 props를 넘겨주지 않고도 컴포넌트 트리 전체에 데이터를 제공할 수 있음 언제 context를 써야 할까 context는 트리 안에서 전역적이라고 볼 수 있는 데이터를 공유하도록 고안된 방법 ex : 현재 로그인한 유저 정보, 테마, 선호 언어 등 API React.createContext context 객체를 만듦 context 객체를 구독하고 있는 컴포넌트를 랜더링할 때 React는 트리 상위에서 가장 가까이 있는 짝이 맞는 Provider로부터 현재값을 읽음 Co…","frontmatter":{"categories":"React","title":"리액트 Context API","date":"July 10, 2024"},"fields":{"slug":"/react-contextApi/"}}},{"node":{"id":"647668d9-26b8-53d8-aa79-34031f4180c0","excerpt":"next.js의 app router 방식에 대해 알아보자. next js 13 버전부터 도입된 방식 알아두면 좋은 점: 앱 라우터는 페이지 라우터보다 우선순위가 높습니다. 디렉터리 간 경로는 동일한 URL 경로로 확인되어서는 안 되며 충돌을 방지하기 위해 빌드 시간 오류가 발생합니다. 프로젝트 구조 최상위 폴더\r\n 폴더 설명 app 앱 라우터 page 페이지 라우터 public 정적 에셋 src 일반적인 패턴을 위한 폴더 src 프로젝트 루트에 특별한 Next.js 앱이나 페이지 디렉터리를 두는 대신 Next.js는 src 디렉터리 아래에 애플리케이션 코드를 배치하는 일반적인 패턴도 지원합니다. 이는 대부분 개인과 팀이 선호하는 프로젝트 루트에 있는 프로젝트 구성 파일과 애플리케이션 코드를 분리합니다. src 디렉터리를 사용하려면 앱 라우터 폴더나 페이지 라우터 폴더를 각각 src/app 또는 src/pages로 이동하세요.  라우팅 기본 사항  Tree: 계층 구조를 시각화하기 …","frontmatter":{"categories":"Next","title":"next.js app router","date":"July 05, 2024"},"fields":{"slug":"/next-appRouter/"}}},{"node":{"id":"13d44c07-cfa8-532a-91c5-5e5129d1f7c9","excerpt":"Next.js에서 채팅 구현 소켓 통신에 대해 알기 socket.io 작동 방식 next.js api route 세팅 next 14 app router 프로젝트 tailwind 사용 서버 프레임워크 사용 대신 next api route 사용 회고 일단 app router 방식의 api routes는 socket io 연동이 불가능했다. socket io 사용을 하기 위해 next의 서버에 연결을 해야 했는데 app router는 서버 인스턴스가 제공되지 않았음. 전체 프로젝트는 app router, 채팅 부분만 page로 빼내어 사용 socket.io에 대한 이해 부족 채팅 서비스 구현에 집중해서 socket.io 자체에 대한 학습이 부족했음 때문에 공식문서에 나와있는 next.js 활용 예시와 블로그 글들을 많이 검색했음 공식문서에서는 루트에 server.js를 추가하여 커스텀 서버를 만들라고 함 블로그 예제는 handler의 res를 통해 서버 인스턴스 접근으로 구현 나는 후자…","frontmatter":{"categories":"Next","title":"next.js 채팅 구현","date":"July 04, 2024"},"fields":{"slug":"/next-chatting/"}}},{"node":{"id":"f1d824ce-0f01-5e8d-8319-44fc929cb3ca","excerpt":"Next app router app router 방식은 폴더 네이밍대로 routing이 생긴다. 이게 아주 편리하지만 … 폴더가 많으면 너무 복잡해진다  위와 같이 폴더를 구성하고 components 안에 pages.tsx를 작성하면 (주소)/components 라는 경로의 페이지가 만들어져 버린다 위 같은 문제를 방지하기 위해 next는 폴더 규칙이 있다. Route group route가 될 수 있는 페이지들을 하나의 그룹으로 묶을 수 있게 해줌 규칙은 (name)\r\n Private folder page.tsx를 만들더라도 route를 생성하지 않게 하려면 폴더 앞에 _ 를 붙이면 된다.\r\n Next에서 API KEY 숨기기 API KEY나 환경 변수 같은 것 들은 .env 파일에 저장한다. root에 .env 파일을 만들고 변수 작성하면 됨. 불러올 때 process.env.변수이름 으로 불러오면 된다.","frontmatter":{"categories":"Next","title":"next.js 폴더 구조 + 팁","date":"July 04, 2024"},"fields":{"slug":"/next-folder-tips/"}}},{"node":{"id":"b4e9f8e1-9d1e-5f1b-8273-822be12e3e16","excerpt":"리액트는 key가 동일 할 경우, 동일한 DOM Element를 보여줌 때문에 key를 index로 뒀을 때 문제가 생길 수 있다. 예시 line 22, 23: 추가, 삭제 버튼. 추가 버튼을 누르면 정국 데이터를 list 앞에 추가하고 삭제를 누르면 철수를 삭제한다. line 28: component가 관리하는 list 데이터를 map으로 loop 돌며 div 태그의 key를 index로 지정한다. 추가할 때 \r\n철수 input에 데이터를 입력 \r\n추가 버튼을 눌렀을 때 \r\n이러한 결과를 예상했지만 \r\n이러한 결과가 나온다. list 값이 변경되면서 index를 다시 mapping함 맨 앞에 추가된 정국은 key = 0 key가 동일 할 경우, 동일한 DOM Element 보여줌 삭제할 때 \r\n위 상황에서 삭제를 눌렀을 때 \r\n이러한 결과를 예상하지만 \r\n이러한 결과가 나온다. 삭제가 되면서 다시 mapping 영희가 철수의 index였던 0이 됨 철수 데이터가 영희에게 mapp…","frontmatter":{"categories":"React","title":"리액트 배열의 index로 key를 쓰면 안되는 이유","date":"July 03, 2024"},"fields":{"slug":"/react-mapKeyIndex/"}}},{"node":{"id":"3814e839-ed9c-5eb5-b8c4-a61caa00d547","excerpt":"angular form 종류 앵귤러는 반응형과 템플릿 기반, 두 가지 방식으로 폼을 제공합니다. 방식 설명 반응형 폼 폼 객체 모델에 직접 명시적으로 접근합니다. 템플릿 기반 폼과 비교해보면 이 방식이 확실히 사용하기 편합니다. 반응형 폼 방식은 확장하기 편하고, 재사용하기 쉬우며, 테스트하기 쉽습니다. 애플리케이션에서 폼이 중요한 역할을 하거나 애플리케이션을 반응형 패턴으로 구성했다면 반응형 폼을 사용하는 것이 좋습니다. 템플릿 기반 폼 템플릿에 디렉티브를 활용하는 방식이며 객체 모델은 디렉티브가 직접 관리합니다. 이메일을 입력받는 정도로 폼 구성이 간단하다면 템플릿 기반으로도 충분합니다. 하지만 폼 구성이 복잡해지면 반응형 폼처럼 확장하기는 어렵습니다. 구성이 간단한 폼을 템플릿 안에서만 동작하도록 구현하려면 템플릿 기반 폼을 사용하는 것이 좋습니다. 차이점  반응형 폼 템플릿 기반 폼 폼 모델 구성방식 명시적, 컴포넌트 클래스 안에서 생성 명확하지 않음, 디렉티브 내부 로직이…","frontmatter":{"categories":"Angular","title":"앵귤러 폼","date":"July 03, 2024"},"fields":{"slug":"/angular-form/"}}},{"node":{"id":"c0be0573-a6d9-553a-80c2-9bb9509a0cc9","excerpt":"1. 라이프사이클 컴포넌트의 라이프사이클은 구성 요소의 생성과 파괴 사이에 발생하는 단계의 순서입니다. 각 단계는 구성 요소를 랜더링하고 시간 경과에 따라 업데이트를 확인하는 Angular 프로세스의 다른 부분을 나타냅니다. 이러한 단계 중에 코드를 실행하기 위해 라이프사이클 훅을 구현할 수 있습니다. 모든 주기에서 구현할 필요는 없고, 특정 주기에 구현해야할 기능이 있을 때 필요한 해당 훅 메소드를 구현하면 됩니다. Angular 생명주기 메서드 요약 단계 방법 요약 Creation  표준 JavaScript 클래스 생성자. Angular가 구성 요소를 인스턴스화할 때 실행됩니다. Change Detection  Angular가 모든 구성 요소의 입력을 초기화한 후에 한 번 실행됩니다. Change Detection  구성 요소의 입력이 변경될 때마다 실행됩니다. Change Detection  이 구성 요소의 변경 사항이 확인될 때마다 실행됩니다. Change Detection…","frontmatter":{"categories":"Angular","title":"앵귤러 라이프사이클","date":"July 02, 2024"},"fields":{"slug":"/angular-lifecycle/"}}},{"node":{"id":"2d0b7c2f-be37-5da8-ae3a-07e56238f84b","excerpt":"블로그 시작 ! 드디어 개발 블로그 시작이다.\r\n개발하면서 배웠던 것 들을 나중에 쉽게 기억 할 수 있도록 기록 할 예정이다.\r\n열심히 해보자.","frontmatter":{"categories":"test","title":"시작하는 글","date":"July 01, 2024"},"fields":{"slug":"/start/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"손재형","bio":{"role":"개발자","description":["사용자 경험을 중시하는","능동적으로 일하는","이로운 것을 만드는"],"thumbnail":"sample.png"},"social":{"github":"https://github.com/sonesonjabgo","linkedIn":"https://www.linkedin.com/in/jaehyung-a225b3255/","email":"thswogud02@gmail.com"}}}}},"pageContext":{}},"staticQueryHashes":["1073350324","1956554647","2938748437","3350743975"]}